//7-1. 美好日子
/*
7-1 美好日子
分数 16
作者 黄龙军
单位 绍兴文理学院
据说2021年12月2日是一个美好日子，因为这是一个完全对称日！这里认为一个美好日子是一个共8位数字的完全对称日（例如20211202），其中年份占4位，月份、日份都是2位。对于给定的年份，请判断该年是否存在美好日子。

输入格式:
首先输入一个正整数T（<8000）表示测试数据的组数，然后输入T组测试数据。对于每组测试数据，输入一个年份y（2020<y<10000）。

输出格式:
对于每组测试数据，输出一行。若年份y存在美好日子，则输出该日期，否则输出“none”。引号不必输出。

输入样例:
3
2021
2022
2100
输出样例:
20211202
none
none
说明:
2021年12月2日，顺利接娃放学，晚饭没获差评。谨以此题纪念这个美好日子。
*/
#include<stdio.h>
int main(void)
{
    int T,y,m,i,d;
    scanf("%d",&T);
    for( i=0;i<T;i++)
    {
            scanf("%d",&y);
            m=y%10*10+y/10%10;//12
            d=y/100%10*10+y/1000;//02,2
                switch(m){
                    		case 1:	 case 3:	 case 5:	 case 7:	 case 8:	 case 10:	 case 12:
if(d<=31)
                                printf("%d",10000*y+100*m+d);else printf("none");
                                break;
                    		case 4:	 case 6:	case 9:	case 11:
if(d<=30)
                                printf("%d",10000*y+100*m+d);
                                else printf("none");
                                break;
                    		case 2:if(y%400==0||(y%4==0&&y%100!=0))
{
                               		 if(d<=29)
                                	printf("%d",10000*y+100*m+d);
                                	else printf("none");
                        		}
                        		else
{
                                	if(d<=28)
                               		 printf("%d",10000*y+100*m+d);
                                	else  printf("none");
                    			}
                                break;
                    		default:
                            printf("none");
                }
        if(i<T-1)printf("\n");
    }
    return 0;
}
//方法2：

#include<stdio.h>
int main()
{
    int T,a,b,c,d,f,e,i;
    scanf("%d",&T);
    for(i=1;i<=T;i++)
    {
        scanf("%d",&a);
        b=a/%10;
        c=a/10%10;
        d=a/100%10;
        e=a/1000;
        f=b*10+c;
        if(f<=12&&f>0&&d*10+e<=31)
            printf("%d%d%d%d%d\n",a,b,c,d,e);
        else
            printf("none\n");
    }
    return 0;
}
//7-2 程序设计基础-循环结构-测试-六的倍数之和问题
/*
7-2 程序设计基础-循环结构-测试-六的倍数之和问题
分数 15
作者 万静
单位 北京化工大学
由键盘输入正整数m和n（已知m <= n），请你找出这个区间内（含m，n）的所有6的倍数，计算这些数之和，并输出。 例如输入1和12，则区间内的所有6的倍数为6，12。这些数之和为18。

输入格式:
输入两个正整数m和n，用一个空格隔开。已知1 <= m <= n <= 200。

输出格式:
输出m和n区间的所有6的倍数之和。

输入样例:
在这里给出一组输入。例如：

1 12
输出样例:
18
*/
#include<stdio.h>
int main()
{
    int m,n,i,s;
    s=0;
    scanf("%d %d",&m,&n);
    for(i=m;i<=n;i++)
    {
        if(i%6==0)
            s=s+i;
    }
printf("%d",s);
}
//7-3素因数分解
/*
7-3 素因数分解
分数 15
作者 阎鹏飞
单位 太原理工大学
对于给定的正整数n，输出n的素因数的乘式。

输入格式:
输入一个正整数n，要求1<n≤2 
16
 −1。

输出格式:
输出n的素因数的乘式，要求这些素因数呈非递减排列。

输入样例1:
102
输出样例1:
2*3*17
输入样例2:
980
输出样例2:
2*2*5*7*7

*/
#include<stdio.h>
int main()
{
    int n,x,y;
scanf("%d",&n);
    y=n;
    for(x=2;x<=y&&x>1;x++)
    {
        while(n%x==0)
       {
           n/=x;
           printf("%d",x);
       if(n!=1)
           printf("*");} 
       }         
   }
